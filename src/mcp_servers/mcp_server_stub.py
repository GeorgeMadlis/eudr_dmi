#!/usr/bin/env python
"""
mcp_server_stub.py

Very lightweight "server" stub that reads an MCP config JSON
(e.g., generated by extraction_recipes.py) and exposes a minimal
tool-dispatch interface.

You would replace the internals with a real MCP framework
(Node-based, Python-based, etc.).
"""

from pathlib import Path
from typing import Dict, Any, Callable, Optional

import argparse
import json

from hansen_gfc_example import HansenGFCServer
from era5_cds_mcp import ERA5CDSServer
from gbif_mcp import GBIFServer
from google_solar_mcp import GoogleSolarServer
from maaamet_mcp import MaaametServer
from owid_mcp import OWIDServer
from fao_mcp import FAOServer
from copernicus_landcover_mcp import CopernicusLandcoverServer
from dynamic_world_mcp import DynamicWorldServer
from geobon_ebv_mcp import GeobonEBVServer
from wdpa_mcp import WDPAServer


# Project root is parent of mcp_servers/
BASE_DIR = Path(__file__).parent.parent


class MCPServerStub:
    def __init__(self, config_path: Path):
        self.config_path = config_path
        self.config: Dict[str, Any] = self._load_config()
        self.tools: Dict[str, Callable[..., Any]] = {}
        self._register_tools()

    def _load_config(self) -> Dict[str, Any]:
        with self.config_path.open("r", encoding="utf-8") as f:
            return json.load(f)

    def _register_tools(self) -> None:
        """
        Create dummy Python callables for each tool in the config.
        In a real MCP server, this is where you'd wire up actual logic.
        """
        for tool in self.config.get("tools", []):
            name = tool["name"]

            def _make_dummy(tool_def: Dict[str, Any]) -> Callable[..., Any]:
                def _fn(**kwargs):
                    return {
                        "tool": tool_def["name"],
                        "description": tool_def.get("description"),
                        "arguments_received": kwargs,
                        "status": "not_implemented",
                        "note": "This is a stub; implement real logic here.",
                    }
                return _fn

            self.tools[name] = _make_dummy(tool)

    def list_tools(self) -> Dict[str, Dict[str, Any]]:
        """
        Metadata for the tools available on this server.
        """
        return {
            tool["name"]: {
                "description": tool.get("description"),
                "arguments": tool.get("arguments", {}),
            }
            for tool in self.config.get("tools", [])
        }

    def handle_request(self, tool_name: str, **kwargs) -> Any:
        """
        Very simple dispatcher.
        """
        if tool_name not in self.tools:
            raise ValueError(f"Unknown tool: {tool_name}")
        return self.tools[tool_name](**kwargs)



def _config_path(filename: str) -> Path:
    return BASE_DIR / "config" / "mcp_configs" / filename


RUNTIME_SERVER_REGISTRY: Dict[str, Dict[str, Any]] = {
    "hansen_gfc_mcp": {
        "family": "Hansen_GFC",
        "config_file": _config_path("mcp_Hansen_GFC.json"),
        "dataset_id": "googleapis_global_forest_change",
        "constructor": HansenGFCServer,
        "description": "Hansen Global Forest Change (tiles HTTP server)",
    },
    "era5_cds_mcp": {
        "family": "ERA5",
        "config_file": _config_path("mcp_ERA5.json"),
        "dataset_id": "ecmwf_era5",
        "constructor": ERA5CDSServer,
        "description": "ERA5 Climate Data Store API wrapper",
    },
    "gbif_mcp": {
        "family": "GBIF",
        "config_file": _config_path("mcp_GBIF.json"),
        "dataset_id": "gbif_gbif",
        "constructor": GBIFServer,
        "description": "GBIF biodiversity occurrence API",
    },
    "google_solar_mcp": {
        "family": "Google_Solar",
        "config_file": _config_path("mcp_Google_Solar.json"),
        "dataset_id": "google_solar_api",
        "constructor": GoogleSolarServer,
        "description": "Google Solar API (building insights / layers / GeoTIFF)",
    },
    "maaamet_mcp": {
        "family": "Maaamet_Estonia",
        "config_file": _config_path("mcp_Maa-amet_Geoportaal.json"),
        "dataset_id": "maaamet_geoportaal",
        "constructor": MaaametServer,
        "description": "Maa-amet Estonian Geoportal (OGC WMS/WFS/WCS services)",
    },
    "owid_mcp": {
        "family": "OurWorldInData",
        "config_file": _config_path("mcp_Our_World_in_Data.json"),
        "dataset_id": "ourworldindata_our_world_in_data",
        "constructor": OWIDServer,
        "description": "Our World in Data (global socio-economic indicators)",
    },
    "fao_mcp": {
        "family": "FAO",
        "config_file": _config_path("mcp_FAO_FAOSTAT.json"),
        "dataset_id": "fao_faostat",
        "constructor": FAOServer,
        "description": "FAO FAOSTAT and Hand-in-Hand Geospatial Platform",
    },
    "copernicus_landcover_mcp": {
        "family": "COPERNICUS_LANDCOVER",
        "config_file": _config_path("mcp_COPERNICUS_LANDCOVER.json"),
        "dataset_id": "copernicus_landcover_100m",
        "constructor": CopernicusLandcoverServer,
        "description": "Copernicus Global Land Cover 100m (annual land cover maps)",
    },
    "dynamic_world_mcp": {
        "family": "DYNAMIC_WORLD",
        "config_file": _config_path("mcp_Dynamic_World.json"),
        "dataset_id": "google_dynamic_world",
        "constructor": DynamicWorldServer,
        "description": "Google Dynamic World (near real-time 10m land cover)",
    },
    "geobon_ebv_mcp": {
        "family": "GEOBON_EBV",
        "config_file": _config_path("mcp_GEOBON_EBV.json"),
        "dataset_id": "geobon_ebv_portal",
        "constructor": GeobonEBVServer,
        "description": "GEOBON Essential Biodiversity Variables",
    },
    "wdpa_mcp": {
        "family": "WDPA_PROTECTED_AREAS",
        "config_file": _config_path("mcp_WDPA_PROTECTED_AREAS.json"),
        "dataset_id": "wdpa_protected_areas",
        "constructor": WDPAServer,
        "description": "World Database on Protected Areas (UNEP-WCMC / IUCN)",
    },
}


def list_runtime_servers() -> Dict[str, Dict[str, Any]]:
    """Return lightweight metadata about available runtime servers."""
    summary = {}
    for server_id, entry in RUNTIME_SERVER_REGISTRY.items():
        summary[server_id] = {
            "family": entry["family"],
            "config_file": str(entry["config_file"]),
            "description": entry["description"],
        }
    return summary


def load_runtime_server(
    server_id: str,
    duckdb_path: Optional[Path] = None,
) -> Any:
    """Instantiate a real MCP server implementation from the registry."""
    if server_id not in RUNTIME_SERVER_REGISTRY:
        raise ValueError(f"Unknown server_id '{server_id}'. Available: {list(RUNTIME_SERVER_REGISTRY)}")

    entry = RUNTIME_SERVER_REGISTRY[server_id]
    config_path = entry["config_file"]
    if not config_path.exists():
        raise FileNotFoundError(
            f"Config file '{config_path}' not found. Run regenerate_catalogue.py to rebuild configs."
        )

    default_duckdb = BASE_DIR / "data_db" / "geodata_catalogue.duckdb"
    server = entry["constructor"](
        config_path,
        duckdb_path=duckdb_path if duckdb_path is not None else default_duckdb,
        dataset_id=entry.get("dataset_id"),
    )
    return server


def _print_runtime_server_info(server_id: str, server: Any) -> None:
    entry = RUNTIME_SERVER_REGISTRY[server_id]
    print(f"Loaded runtime server: {server_id} ({entry['description']})")
    public_methods = [
        name for name in dir(server)
        if callable(getattr(server, name)) and not name.startswith("_")
    ]
    print("Available callables:")
    for name in sorted(public_methods):
        print(f" - {name}")


def _run_stub_mode(config_path: Path) -> None:
    server = MCPServerStub(config_path)
    print("Available tools:")
    for name, meta in server.list_tools().items():
        print(f" - {name}: {meta['description']}")

    # Call a dummy tool to demonstrate the stub
    first_tool = next(iter(server.tools), None)
    if not first_tool:
        print("No tools declared in config.")
        return

    print(f"\nDummy response from {first_tool}:")
    response = server.handle_request(first_tool)
    print(json.dumps(response, indent=2))


def main() -> None:
    parser = argparse.ArgumentParser(description="Minimal MCP runtime/stub helper")
    parser.add_argument(
        "--mode",
        choices=["stub", "runtime"],
        default="stub",
        help="Run config stub mode (default) or instantiate a real MCP server",
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=_config_path("mcp_Hansen_GFC.json"),
        help="Config JSON to load in stub mode",
    )
    parser.add_argument(
        "--server-id",
        choices=sorted(RUNTIME_SERVER_REGISTRY.keys()),
        help="Runtime server id to load (required for runtime mode)",
    )
    parser.add_argument(
        "--duckdb",
        type=Path,
        default=None,
        help="Optional path to geodata_catalogue.duckdb for runtime mode",
    )
    parser.add_argument(
        "--list",
        action="store_true",
        help="List available runtime servers and exit",
    )

    args = parser.parse_args()

    if args.list:
        print("Available runtime servers:")
        for server_id, meta in list_runtime_servers().items():
            print(f" - {server_id}: {meta['description']} (family={meta['family']})")
            print(f"   Config: {meta['config_file']}")
        return

    if args.mode == "runtime":
        if not args.server_id:
            parser.error("--server-id is required when --mode runtime is selected")
        server = load_runtime_server(args.server_id, duckdb_path=args.duckdb)
        _print_runtime_server_info(args.server_id, server)
        return

    # Stub mode (default)
    if not args.config.exists():
        raise FileNotFoundError(
            f"Config file not found at {args.config}. Run regenerate_catalogue.py first."
        )
    _run_stub_mode(args.config)


if __name__ == "__main__":
    main()
